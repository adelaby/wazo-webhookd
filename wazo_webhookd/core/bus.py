# Copyright 2017 The Wazo Authors  (see the AUTHORS file)
# SPDX-License-Identifier: GPL-3.0+

import logging
import kombu
import kombu.mixins

from collections import deque
from contextlib import contextmanager
from werkzeug.datastructures import MultiDict
from xivo.pubsub import Pubsub

logger = logging.getLogger(__name__)


class CoreBusConsumer(kombu.mixins.ConsumerMixin):

    def __init__(self, global_config):
        self._all_events_pubsub = Pubsub()
        self._is_running = False
        self.connection = None

        self._bus_url = 'amqp://{username}:{password}@{host}:{port}//'.format(**global_config['bus'])
        self._upstream_exchange = kombu.Exchange(global_config['bus']['exchange_name'],
                                                 type=global_config['bus']['exchange_type'])
        self._exchange = kombu.Exchange(global_config['bus']['exchange_headers_name'],
                                        type='headers')
        self._consumers = {}
        self._new_consumers = deque()
        self._stale_consumers = deque()
        self._updated_consumers = deque()

    def run(self):
        logger.info("Running bus consumer")
        with kombu.Connection(self._bus_url) as connection:
            self.connection = connection

            super(CoreBusConsumer, self).run()

    def get_consumers(self, Consumer, channel):
        for consumer in self._consumers.values():
            self._reset_queue_names(consumer)
            consumer.revive(channel)
        return self._consumers.values()

    def _reset_queue_names(self, consumer):
        '''When reconnecting, the old autogenerated queue does not exist,
        and we can't use the autogenerated name to declare a new queue.
        '''
        for queue_ in consumer.queues:
            queue_.name = None

    def on_connection_error(self, exc, interval):
        super(CoreBusConsumer, self).on_connection_error(exc, interval)
        for consumer in self._consumers:
            try:
                consumer.cancel()
            except Exception:
                pass
        self._is_running = False

    def on_connection_revived(self):
        super(CoreBusConsumer, self).on_connection_revived()
        self._is_running = True

    @contextmanager
    def extra_context(self, connection, channel):
        self._active_connection = connection
        self._upstream_exchange.bind(connection).declare()
        exchange = self._exchange.bind(connection)
        exchange.declare()
        exchange.bind_to(self._upstream_exchange, routing_key='#')
        yield

    def on_iteration(self):
        while self._new_consumers:
            uuid, consumer = self._new_consumers.pop()
            logger.debug('Adding consumer (uuid: %s)', uuid)
            consumer.revive(self._active_connection)
            consumer.consume()
            self._consumers[uuid] = consumer

        while self._updated_consumers:
            uuid, new_binding = self._updated_consumers.pop()
            logger.debug('Changing consumer binding (uuid: %s)', uuid)
            try:
                consumer = self._consumers[uuid]
            except KeyError:
                logger.error('%s: consumer not found')
                continue

            for queue in consumer.queues:
                new_binding.bind(queue)
                for binding in queue.bindings:
                    binding.unbind(queue)
                queue.bindings = [new_binding]

        while self._stale_consumers:
            uuid = self._stale_consumers.pop()
            logger.debug('Removing consumer (uuid: %s)', uuid)
            try:
                consumer = self._consumers.pop(uuid)
            except KeyError:
                logger.warning('Tried to remove unknown consumer (uuid: %s)', uuid)
                continue

            consumer.cancel()

    def is_running(self):
        return self._is_running

    def subscribe_to_event_names(self, uuid, event_names, callback):
        logger.debug('Subscribing new callback to events %s (uuid: %s)', event_names, uuid)
        queue = kombu.Queue(exclusive=True, bindings=[self._create_binding(event_names)])
        consumer = kombu.Consumer(channel=None, queues=queue, callbacks=[callback])
        self._new_consumers.append((uuid, consumer))

    def change_subscription(self, uuid, event_names):
        logger.debug('Changing subscription for callback (uuid: %s)', uuid)
        self._updated_consumers.append((uuid, self._create_binding(event_names)))

    def unsubscribe_from_event_names(self, uuid):
        logger.debug('Unsubscribing callback (uuid: %s)', uuid)
        self._stale_consumers.append(uuid)

    def _create_binding(self, event_names):
        arguments = MultiDict()
        arguments['x-match'] = 'any'
        for event_name in event_names:
            arguments['name'] = event_name

        return kombu.binding(exchange=self._exchange,
                             arguments=arguments,
                             unbind_arguments=arguments)
