# Copyright 2017 The Wazo Authors  (see the AUTHORS file)
# SPDX-License-Identifier: GPL-3.0+

import logging
import kombu
import kombu.mixins

from collections import deque
from contextlib import contextmanager
from werkzeug.datastructures import MultiDict
from xivo.pubsub import Pubsub

logger = logging.getLogger(__name__)


class CoreBusConsumer(kombu.mixins.ConsumerMixin):

    def __init__(self, global_config):
        self._all_events_pubsub = Pubsub()
        self._is_running = False
        self.connection = None

        self._bus_url = 'amqp://{username}:{password}@{host}:{port}//'.format(**global_config['bus'])
        self._upstream_exchange = kombu.Exchange(global_config['bus']['exchange_name'],
                                                 type=global_config['bus']['exchange_type'])
        self._exchange = kombu.Exchange(global_config['bus']['exchange_headers_name'],
                                        type='headers')
        self._consumers = {}
        self._new_consumers = deque()
        self._stale_consumers = deque()

    def run(self):
        logger.info("Running bus consumer")
        with kombu.Connection(self._bus_url) as connection:
            self.connection = connection

            super(CoreBusConsumer, self).run()

    def get_consumers(self, Consumer, channel):
        for consumer in self._consumers.values():
            self._reset_queue_names(consumer)
            consumer.revive(channel)
        return self._consumers.values()

    def _reset_queue_names(self, consumer):
        '''When reconnecting, the old autogenerated queue does not exist,
        and we can't use the autogenerated name to declare a new queue.
        '''
        for queue_ in consumer.queues:
            queue_.name = None

    def on_connection_error(self, exc, interval):
        super(CoreBusConsumer, self).on_connection_error(exc, interval)
        for consumer in self._consumers:
            try:
                consumer.cancel()
            except Exception:
                pass
        self._is_running = False

    def on_connection_revived(self):
        super(CoreBusConsumer, self).on_connection_revived()
        self._is_running = True

    @contextmanager
    def extra_context(self, connection, channel):
        self._active_connection = connection
        self._upstream_exchange.bind(connection).declare()
        exchange = self._exchange.bind(connection)
        exchange.declare()
        exchange.bind_to(self._upstream_exchange, routing_key='#')
        yield

    def on_iteration(self):
        while self._new_consumers:
            uuid = self._new_consumers.pop()
            logger.debug('Adding consumer (uuid: %s)', uuid)
            try:
                consumer = self._consumers[uuid]
            except KeyError:
                logger.error('%s: consumer not found')
                continue
            consumer.revive(self._active_connection)
            consumer.consume()

        while self._stale_consumers:
            uuid = self._stale_consumers.pop()
            logger.debug('Removing consumer (uuid: %s)', uuid)
            try:
                consumer = self._consumers.pop(uuid)
            except KeyError:
                logger.warning('Tried to remove unknown consumer (uuid: %s)', uuid)
                continue

            consumer.cancel()

    def is_running(self):
        return self._is_running

    def subscribe_to_event_names(self, uuid, event_names, callback):
        logger.debug('Subscribing new callback to events %s (uuid: %s)', event_names, uuid)
        binding_args = MultiDict()
        binding_args['x-match'] = 'any'
        for event_name in event_names:
            binding_args['name'] = event_name
        queue = kombu.Queue(exclusive=True,
                            exchange=self._exchange,
                            binding_arguments=binding_args)
        consumer = kombu.Consumer(channel=None,
                                  queues=queue,
                                  callbacks=[callback])
        self._consumers[uuid] = consumer
        self._new_consumers.append(uuid)

    def unsubscribe_from_event_names(self, uuid):
        logger.debug('Unsubscribing callback (uuid: %s)', uuid)
        self._stale_consumers.append(uuid)
